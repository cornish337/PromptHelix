{% extends "base.html" %}

{% block title %}Real-Time Dashboard{% endblock %}

{% block content %}
<div class="container mx-auto p-4">
    <h1 class="text-2xl font-bold mb-4">Real-Time Monitoring Dashboard</h1>

    <!-- GA Progress Section -->
    <section id="ga-progress" class="mb-6 p-4 bg-white rounded shadow border border-gray-200">
        <h2 class="text-xl font-semibold mb-3">Genetic Algorithm Progress</h2>
        <div id="ga-progress-data">
            <div class="grid grid-cols-1 md:grid-cols-2 gap-x-6 gap-y-3 mb-4">
                <div>
                    <span class="font-semibold text-gray-700">GA Status:</span>
                    <span id="ga-status" class="text-gray-900">Idle</span>
                </div>
                <div>
                    <span class="font-semibold text-gray-700">Current Generation:</span>
                    <span id="ga-generation" class="text-gray-900">-</span>
                </div>
                <div>
                    <span class="font-semibold text-gray-700">Best Fitness:</span>
                    <span id="ga-best-fitness" class="text-gray-900">-</span>
                </div>
                <div>
                    <span class="font-semibold text-gray-700">Agents Used:</span>
                    <span id="ga-agents-used" class="text-gray-900">-</span>
                </div>
                <div class="md:col-span-2">
                    <span class="font-semibold text-gray-700">Fittest Chromosome:</span>
                    <pre id="ga-fittest-chromosome" class="text-gray-900 bg-gray-100 p-2 rounded mt-1 overflow-x-auto">-</pre>
                </div>
                <!-- New Fitness Statistics -->
                <div>
                    <span class="font-semibold text-gray-700">Min Fitness:</span>
                    <span id="ga-min-fitness" class="text-gray-900">-</span>
                </div>
                <div>
                    <span class="font-semibold text-gray-700">Max Fitness:</span>
                    <span id="ga-max-fitness" class="text-gray-900">-</span>
                </div>
                <div>
                    <span class="font-semibold text-gray-700">Mean Fitness:</span>
                    <span id="ga-mean-fitness" class="text-gray-900">-</span>
                </div>
                <div>
                    <span class="font-semibold text-gray-700">Median Fitness:</span>
                    <span id="ga-median-fitness" class="text-gray-900">-</span>
                </div>
                <div>
                    <span class="font-semibold text-gray-700">Std Dev Fitness:</span>
                    <span id="ga-stddev-fitness" class="text-gray-900">-</span>
                </div>
            </div>
            <div class="mt-4 flex space-x-2">
                <button id="ga-pause-btn" class="bg-amber-500 hover:bg-amber-600 text-white font-bold py-2 px-4 rounded disabled:opacity-50 disabled:cursor-not-allowed transition-colors duration-150 ease-in-out">Pause</button>
                <button id="ga-resume-btn" class="bg-emerald-500 hover:bg-emerald-600 text-white font-bold py-2 px-4 rounded disabled:opacity-50 disabled:cursor-not-allowed transition-colors duration-150 ease-in-out">Resume</button>
                <button id="ga-cancel-btn" class="bg-rose-500 hover:bg-rose-600 text-white font-bold py-2 px-4 rounded disabled:opacity-50 disabled:cursor-not-allowed transition-colors duration-150 ease-in-out">Cancel</button>
            </div>
            <!-- Chart.js Canvas -->
            <div class="mt-4 flex items-center space-x-3">
                <input type="checkbox" id="toggle-chart" class="h-4 w-4" checked>
                <label for="toggle-chart" class="text-sm text-gray-700">Show Chart</label>
                <button id="download-csv" class="bg-blue-500 hover:bg-blue-600 text-white text-sm font-semibold py-1 px-2 rounded">Download CSV</button>
            </div>
            <div id="ga-charts-placeholder" class="mt-2">
                <canvas id="ga-history-chart"></canvas>
            </div>

            <!-- Population Snapshot Section -->
            <div id="population-snapshot" class="mt-6">
                <h3 class="text-lg font-semibold mb-2">Population Snapshot (Top 5)</h3>
                <div id="population-sample-container" class="space-y-2">
                    <p class="text-gray-500">Waiting for population data...</p>
                </div>
            </div>
        </div>
    </section>

    <!-- Conversation Logs Section -->
    <section id="conversation-logs" class="mb-6 p-4 bg-white rounded shadow border border-gray-200">
        <h2 class="text-xl font-semibold mb-3">Live Conversation Logs</h2>
        <div id="logs-container" class="max-h-96 overflow-y-auto space-y-2 pr-2 border rounded p-2 bg-gray-50">
            <!-- Logs will be appended here by JavaScript -->
            <div class="log-entry text-gray-500">Waiting for logs...</div>
        </div>
    </section> <!-- Conversation Logs Section -->

    <!-- Debug Logs Section -->
    <section id="debug-logs" class="mb-6 p-4 bg-white rounded shadow border border-gray-200">
        <div class="flex justify-between items-center mb-3">
            <h2 class="text-xl font-semibold">Real-Time Debug Logs</h2>
            <div class="flex items-center">
                <input type="checkbox" id="toggle-debug-logs" class="form-checkbox h-5 w-5 text-blue-600 rounded focus:ring-blue-500" checked>
                <label for="toggle-debug-logs" class="ml-2 text-sm text-gray-700">Show Debug Logs</label>
            </div>
        </div>
        <div id="debug-logs-container" class="max-h-96 overflow-y-auto space-y-2 pr-2 border rounded p-2 bg-gray-50">
            <!-- Debug logs will be appended here by JavaScript -->
            <div class="log-entry text-gray-500">Waiting for debug logs...</div>
        </div>
    </section>

    <!-- Agent Metrics Section -->
    <section id="agent-metrics" class="p-4 bg-white rounded shadow border border-gray-200">
        <h2 class="text-xl font-semibold mb-3">Agent Metrics</h2>
        <div id="agent-metrics-data">
            <p>Metrics will appear here.</p>
            <!-- Placeholder for metrics display -->
        </div>
    </section>

</div>

<script src="{{ url_for('static', path='chart.min.js') }}"></script>
<script>
    function escapeHtml(unsafe) {
        if (unsafe === null || typeof unsafe === 'undefined') {
            return '';
        }
        return unsafe
             .replace(/&/g, "&amp;")
             .replace(/</g, "&lt;")
             .replace(/>/g, "&gt;")
             .replace(/"/g, "&quot;")
             .replace(/'/g, "&#039;");
    }

    document.addEventListener('DOMContentLoaded', function() {
        // Helper logic for agent colors in conversation logs
        const agentColors = {};
        const predefinedColors = [
            { bg: 'bg-sky-50', text: 'text-sky-700', border: 'border-sky-300' },
            { bg: 'bg-amber-50', text: 'text-amber-700', border: 'border-amber-300' },
            { bg: 'bg-violet-50', text: 'text-violet-700', border: 'border-violet-300' },
            { bg: 'bg-lime-50', text: 'text-lime-700', border: 'border-lime-300' },
            { bg: 'bg-pink-50', text: 'text-pink-700', border: 'border-pink-300' },
            { bg: 'bg-teal-50', text: 'text-teal-700', border: 'border-teal-300' },
            { bg: 'bg-fuchsia-50', text: 'text-fuchsia-700', border: 'border-fuchsia-300' },
            { bg: 'bg-rose-50', text: 'text-rose-700', border: 'border-rose-300' }
        ];
        let nextColorIndex = 0;

        function getAgentColorStyle(agentId) {
            if (!agentId || agentId === 'SYSTEM' || agentId.toLowerCase().includes('user')) {
                // Specific styling for SYSTEM or user messages
                if (agentId === 'SYSTEM') {
                    return { bg: 'bg-yellow-50', text: 'text-yellow-700', border: 'border-yellow-300' };
                }
                // Default for user or unspecified non-agent senders
                return { bg: 'bg-gray-100', text: 'text-gray-700', border: 'border-gray-300' };
            }
            if (!agentColors[agentId]) {
                agentColors[agentId] = predefinedColors[nextColorIndex % predefinedColors.length];
                nextColorIndex++;
            }
            return agentColors[agentId];
        }

        const gaStatus = document.getElementById('ga-status');
        const gaGeneration = document.getElementById('ga-generation');
        const gaBestFitness = document.getElementById('ga-best-fitness');
        const gaMinFitness = document.getElementById('ga-min-fitness'); // New
        const gaMaxFitness = document.getElementById('ga-max-fitness'); // New
        const gaMeanFitness = document.getElementById('ga-mean-fitness'); // New
        const gaMedianFitness = document.getElementById('ga-median-fitness'); // New
        const gaStdDevFitness = document.getElementById('ga-stddev-fitness'); // New
        const gaAgentsUsed = document.getElementById('ga-agents-used');
        const gaFittestChromosome = document.getElementById('ga-fittest-chromosome');
        const populationSampleContainer = document.getElementById('population-sample-container'); // Added
        const logsContainer = document.getElementById('logs-container');
        const agentMetricsData = document.getElementById('agent-metrics-data');
        const debugLogsContainer = document.getElementById('debug-logs-container'); // Add this
        const toggleDebugLogs = document.getElementById('toggle-debug-logs'); // Add this

        const gaPauseBtn = document.getElementById('ga-pause-btn');
        const gaResumeBtn = document.getElementById('ga-resume-btn');
        const gaCancelBtn = document.getElementById('ga-cancel-btn');

        let fitnessChart = null;
        let gaHistoryData = [];
        const chartData = {
            labels: [],
            datasets: [
                {
                    label: 'Best Fitness',
                    borderColor: 'rgb(99,102,241)',
                    backgroundColor: 'rgba(99,102,241,0.3)',
                    data: [],
                    tension: 0.1
                },
                {
                    label: 'Average Fitness',
                    borderColor: 'rgb(16,185,129)',
                    backgroundColor: 'rgba(16,185,129,0.3)',
                    data: [],
                    tension: 0.1
                },
                {
                    label: 'Min Fitness',
                    borderColor: 'rgb(239,68,68)',
                    backgroundColor: 'rgba(239,68,68,0.3)',
                    data: [],
                    tension: 0.1
                }
            ]
        };

        function initializeFitnessChart() {
            const ctx = document.getElementById('ga-history-chart').getContext('2d');
            if (fitnessChart) {
                fitnessChart.destroy(); // Destroy existing chart if any
            }
            fitnessChart = new Chart(ctx, {
                type: 'line',
                data: chartData,
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        x: {
                            title: {
                                display: true,
                                text: 'Generation'
                            }
                        },
                        y: {
                            title: {
                                display: true,
                                text: 'Fitness Score'
                            },
                            beginAtZero: true // Adjust as needed
                        }
                    },
                    plugins: {
                        legend: {
                            position: 'top',
                        },
                        title: {
                            display: true,
                            text: 'Fitness Trend Over Generations'
                        }
                    }
                }
            });
        }


        // Function to handle GA data updates from WebSocket
        function handleGaDataUpdate(data) {
            gaStatus.textContent = data.status || 'N/A';
            updateStatusBadge(gaStatus.textContent);
            gaGeneration.textContent = data.generation !== undefined ? data.generation : '-';
            gaBestFitness.textContent = data.best_fitness !== null && data.best_fitness !== undefined ? parseFloat(data.best_fitness).toFixed(4) : '-';

            // Update new fitness stats
            gaMinFitness.textContent = data.fitness_min !== null && data.fitness_min !== undefined ? parseFloat(data.fitness_min).toFixed(4) : '-';
            gaMaxFitness.textContent = data.fitness_max !== null && data.fitness_max !== undefined ? parseFloat(data.fitness_max).toFixed(4) : '-';
            gaMeanFitness.textContent = data.fitness_mean !== null && data.fitness_mean !== undefined ? parseFloat(data.fitness_mean).toFixed(4) : '-';
            gaMedianFitness.textContent = data.fitness_median !== null && data.fitness_median !== undefined ? parseFloat(data.fitness_median).toFixed(4) : '-';
            gaStdDevFitness.textContent = data.fitness_std_dev !== null && data.fitness_std_dev !== undefined ? parseFloat(data.fitness_std_dev).toFixed(4) : '-';

            if (data.agents_used && Array.isArray(data.agents_used)) {
                gaAgentsUsed.textContent = data.agents_used.join(', ') || 'N/A';
            } else {
                gaAgentsUsed.textContent = 'N/A';
            }
            gaFittestChromosome.textContent = data.fittest_chromosome_string || 'N/A';
            updateGaControlButtons(data.status);

            if (data.agent_metrics) {
                const metricsContainer = document.getElementById('agent-metrics-data');
                let table = document.getElementById('agent-metrics-table');
                if (!table) {
                    table = document.createElement('table');
                    table.id = 'agent-metrics-table';
                    table.classList.add('min-w-full', 'text-sm', 'table-auto', 'border-collapse');
                    table.innerHTML = `
                        <thead>
                            <tr>
                                <th class="border px-2">Agent</th>
                                <th class="border px-2">Messages</th>
                                <th class="border px-2">Errors</th>
                                <th class="border px-2">Last Operation</th>
                                <th class="border px-2">Avg Fitness Δ</th>
                                <th class="border px-2">Updated</th>
                            </tr>
                        </thead>
                        <tbody></tbody>`;
                    metricsContainer.innerHTML = '';
                    metricsContainer.appendChild(table);
                }

                const tbody = table.querySelector('tbody');
                Object.entries(data.agent_metrics).forEach(([id, m]) => {
                    let row = tbody.querySelector(`tr[data-agent-id="${id}"]`);
                    if (!row) {
                        row = document.createElement('tr');
                        row.dataset.agentId = id;
                        tbody.appendChild(row);
                    }
                    const avgDelta = m.average_fitness_change !== undefined && m.average_fitness_change !== null
                        ? parseFloat(m.average_fitness_change).toFixed(4)
                        : '-';
                    row.innerHTML = `
                        <td class="border px-2">${id}</td>
                        <td class="border px-2">${m.messages_processed}</td>
                        <td class="border px-2">${m.errors_encountered}</td>
                        <td class="border px-2">${m.last_operation_type || '-'}</td>
                        <td class="border px-2">${avgDelta}</td>
                        <td class="border px-2">${new Date(m.timestamp).toLocaleTimeString()}</td>
                    `;
                });
            }

            // Update chart if generation data is present and it's a relevant event
            // Consider "ga_evaluation_complete" or "ga_generation_complete" as good points to update chart
            // For simplicity, updating if generation and fitness_mean are present
            if (data.generation !== undefined && data.best_fitness !== null && data.best_fitness !== undefined) {
                // Avoid duplicate generation numbers in labels if data comes too rapidly for same generation
                if (!chartData.labels.includes(data.generation)) {
                    chartData.labels.push(data.generation);
                } else {
                    // If generation already exists, find its index to update data instead of pushing
                    // This handles cases where multiple updates for the same generation might arrive
                    // For simplicity here, we'll assume unique generation updates or let Chart.js handle it
                    // A more robust way would be to map generations to indices.
                }

                // Ensure data arrays are appended to correctly or updated if generation label already existed
                // This basic implementation assumes new generation data comes sequentially
                // For a new generation, push data. If updating existing, replace at index.
                // Current logic: always appends if generation is new, which is typical for GA progress.
                const currentLabelIndex = chartData.labels.indexOf(data.generation);

                if (currentLabelIndex === chartData.datasets[0].data.length) { // New data point
                    chartData.datasets[0].data.push(parseFloat(data.best_fitness));
                    chartData.datasets[1].data.push(parseFloat(data.fitness_mean));
                    chartData.datasets[2].data.push(parseFloat(data.fitness_min));
                    gaHistoryData.push({generation: data.generation, best_fitness: data.best_fitness, fitness_mean: data.fitness_mean, fitness_min: data.fitness_min});
                } else if (currentLabelIndex !== -1 && currentLabelIndex < chartData.datasets[0].data.length) { // Update existing data point
                    chartData.datasets[0].data[currentLabelIndex] = parseFloat(data.best_fitness);
                    chartData.datasets[1].data[currentLabelIndex] = parseFloat(data.fitness_mean);
                    chartData.datasets[2].data[currentLabelIndex] = parseFloat(data.fitness_min);
                    gaHistoryData[currentLabelIndex] = {generation: data.generation, best_fitness: data.best_fitness, fitness_mean: data.fitness_mean, fitness_min: data.fitness_min};
                }


                if (fitnessChart) {
                    fitnessChart.update();
                }
            }

            // Handle population sample display
            if (populationSampleContainer) { // Check if the container exists
                if (data.population_sample && Array.isArray(data.population_sample)) {
                    populationSampleContainer.innerHTML = ''; // Clear previous content
                    const selectedParentIds = (data.selected_parent_ids && Array.isArray(data.selected_parent_ids)) ? data.selected_parent_ids : [];

                    if (data.population_sample.length > 0) {
                        data.population_sample.forEach(chromosome => {
                            const chromosomeDiv = document.createElement('div');
                            const isParent = selectedParentIds.includes(chromosome.id);
                            const parentClass = isParent ? 'is-selected-parent' : '';
                            const parentBadge = isParent ? '<span class="parent-badge ml-2 text-xs bg-green-200 text-green-800 px-1.5 py-0.5 rounded-full">Parent</span>' : '';

                            chromosomeDiv.className = `chromosome-entry p-2 border rounded bg-gray-50 text-xs ${parentClass}`;

                            let genesHtml = '<ul class="list-disc list-inside pl-4 mt-1">';
                            chromosome.genes.forEach(gene => {
                                genesHtml += `<li>${escapeHtml(gene)}</li>`;
                            });
                            genesHtml += '</ul>';

                            chromosomeDiv.innerHTML = `
                                <p class="text-xs font-medium">ID: <span class="font-normal">${escapeHtml(chromosome.id)}</span> | Fitness: <span class="font-normal">${parseFloat(chromosome.fitness_score).toFixed(4)}</span>${parentBadge}</p>
                                <p class="text-xs font-medium mt-1">Genes:</p>
                                ${genesHtml}
                            `;
                            populationSampleContainer.appendChild(chromosomeDiv);
                        });
                    } else {
                        populationSampleContainer.innerHTML = '<p class="text-gray-500">Population sample is empty.</p>';
                    }
                } else if (data.hasOwnProperty('population_sample') &&
                           (data.population_sample === null || data.population_sample === undefined || (Array.isArray(data.population_sample) && data.population_sample.length === 0)) ) {
                    // This condition ensures that if 'population_sample' is explicitly sent as null, undefined, or an empty array,
                    // we update the container, rather than leaving stale data.
                    if (populationSampleContainer.innerHTML.includes("Waiting for population data...")) {
                        // It's fine, initial state or no data yet. Message will be updated if sample is empty.
                    } else if (Array.isArray(data.population_sample) && data.population_sample.length === 0) {
                        populationSampleContainer.innerHTML = '<p class="text-gray-500">Population sample is empty.</p>';
                    } else {
                         populationSampleContainer.innerHTML = '<p class="text-gray-500">Population sample data not available.</p>';
                    }
                }
                // If data.population_sample key is not in the message at all, the "Waiting..." message (or previous content) remains.
            }
            // console.log("GA Data Processed for event type, data:", data);
        }

        function updateStatusBadge(statusText) {
            const statusElement = document.getElementById('ga-status');
            if (!statusElement) return;

            // Remove existing color classes and base styling classes to avoid accumulation
            const classesToRemove = Array.from(statusElement.classList).filter(cls =>
                cls.startsWith('bg-') || cls.startsWith('text-') ||
                ['px-2.5', 'py-1', 'rounded-md', 'text-xs', 'font-semibold', 'inline-block'].includes(cls)
            );
            statusElement.classList.remove(...classesToRemove);

            // Add base styling for the badge
            statusElement.classList.add('px-2.5', 'py-1', 'rounded-md', 'text-xs', 'font-semibold', 'inline-block');

            if (!statusText) statusText = 'IDLE'; // Default if undefined or null

            switch (statusText.toUpperCase()) {
                case 'RUNNING':
                    statusElement.classList.add('bg-green-100', 'text-green-800');
                    break;
                case 'PAUSED':
                    statusElement.classList.add('bg-yellow-100', 'text-yellow-800');
                    break;
                case 'INITIALIZING':
                case 'STOPPING':
                    statusElement.classList.add('bg-blue-100', 'text-blue-800');
                    break;
                case 'ERROR':
                    statusElement.classList.add('bg-red-100', 'text-red-800');
                    break;
                case 'IDLE':
                case 'COMPLETED':
                case 'CANCELLED': // Assuming CANCELLED is a possible status
                default:
                    statusElement.classList.add('bg-gray-100', 'text-gray-800');
                    break;
            }
        }

        function updateGaControlButtons(gaStatusString) {
            const status = gaStatusString ? gaStatusString.toUpperCase() : 'IDLE';
            if (!gaPauseBtn || !gaResumeBtn || !gaCancelBtn) return; // Buttons not found

            // Default states
            gaPauseBtn.disabled = true;
            gaResumeBtn.disabled = true;
            gaCancelBtn.disabled = true;

            if (status === 'RUNNING') {
                gaPauseBtn.disabled = false;
                gaCancelBtn.disabled = false;
            } else if (status === 'PAUSED') {
                gaResumeBtn.disabled = false;
                gaCancelBtn.disabled = false;
            } else if (status === 'INITIALIZING' || status === 'STOPPING') {
                // All buttons disabled while initializing or stopping
                gaCancelBtn.disabled = false; // Allow cancelling if stuck in initializing/stopping
            }
            // For IDLE, COMPLETED, STOPPED, ERROR, all remain disabled (default)
        }

        async function fetchInitialGaStatus() {
            try {
                const response = await fetch('/api/ga/status');
                if (response.ok) {
                    const statusData = await response.json();
                    console.log('Initial GA Status:', statusData);
                    // Update UI elements based on this initial status
                    gaStatus.textContent = statusData.status || 'N/A';
                    updateStatusBadge(gaStatus.textContent);
                    gaGeneration.textContent = statusData.generation !== undefined ? statusData.generation : '-';
                    gaBestFitness.textContent = statusData.best_fitness !== null && statusData.best_fitness !== undefined ? parseFloat(statusData.best_fitness).toFixed(4) : '-';

                    // Update new fitness stats from initial fetch
                    gaMinFitness.textContent = statusData.fitness_min !== null && statusData.fitness_min !== undefined ? parseFloat(statusData.fitness_min).toFixed(4) : '-';
                    gaMaxFitness.textContent = statusData.fitness_max !== null && statusData.fitness_max !== undefined ? parseFloat(statusData.fitness_max).toFixed(4) : '-';
                    gaMeanFitness.textContent = statusData.fitness_mean !== null && statusData.fitness_mean !== undefined ? parseFloat(statusData.fitness_mean).toFixed(4) : '-';
                    gaMedianFitness.textContent = statusData.fitness_median !== null && statusData.fitness_median !== undefined ? parseFloat(statusData.fitness_median).toFixed(4) : '-';
                    gaStdDevFitness.textContent = statusData.fitness_std_dev !== null && statusData.fitness_std_dev !== undefined ? parseFloat(statusData.fitness_std_dev).toFixed(4) : '-';

                    if (statusData.agents_used && Array.isArray(statusData.agents_used)) {
                        gaAgentsUsed.textContent = statusData.agents_used.join(', ') || 'N/A';
                    } else {
                        gaAgentsUsed.textContent = 'N/A';
                    }
                    gaFittestChromosome.textContent = statusData.fittest_chromosome_string || 'N/A';

                    updateGaControlButtons(statusData.status);

                    // Initialize chart with potentially empty data from initial status,
                    // or if historical data was part of statusData (not assumed here)
                    // For now, chart is initialized empty and populates with WebSocket data.
                    // If statusData contains initial points for the chart:
                    // if (statusData.generation !== undefined && statusData.fitness_mean !== null) {
                    //    chartData.labels.push(statusData.generation);
                    //    chartData.datasets[0].data.push(parseFloat(statusData.fitness_max));
                    //    chartData.datasets[1].data.push(parseFloat(statusData.fitness_mean));
                    //    chartData.datasets[2].data.push(parseFloat(statusData.fitness_min));
                    // }
                    // initializeFitnessChart(); // Call after potentially populating chartData

                } else {
                    console.error('Failed to fetch initial GA status:', response.status);
                    gaStatus.textContent = 'Error'; // Update text before badge
                    updateStatusBadge('Error');
                    updateGaControlButtons('ERROR'); // Assume error if status fetch fails
                }
            } catch (error) {
                console.error('Error fetching initial GA status:', error);
                gaStatus.textContent = 'Error'; // Update text before badge
                updateStatusBadge('Error');
                updateGaControlButtons('ERROR'); // Assume error on error
            }
        }

        async function fetchGaHistory() {
            try {
                const response = await fetch('/api/ga/history');
                if (response.ok) {
                    const history = await response.json();
                    gaHistoryData = history;
                    chartData.labels = history.map(h => h.generation);
                    chartData.datasets[0].data = history.map(h => h.best_fitness);
                    chartData.datasets[1].data = history.map(h => h.fitness_mean);
                    chartData.datasets[2].data = history.map(h => h.fitness_min);
                } else {
                    console.error('Failed to fetch GA history:', response.status);
                }
            } catch (err) {
                console.error('Error fetching GA history:', err);
            }
            initializeFitnessChart();
        }

        // Determine WebSocket protocol
        const wsProtocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
        const wsUrl = `${wsProtocol}//${window.location.host}/ws/dashboard`;

        console.log(`Attempting to connect to WebSocket at: ${wsUrl}`);
        const socket = new WebSocket(wsUrl);

        socket.onopen = function(event) {
            console.log("WebSocket connection established.");
            logsContainer.innerHTML = '<div class="log-entry text-green-600">Connected to real-time updates.</div>';
            socket.send(JSON.stringify({ message: "Hello Server from Dashboard!" }));
        };

        socket.onmessage = function(event) {
            console.log("WebSocket message received:", event.data);
            const message = JSON.parse(event.data);

            if (message.type === 'new_conversation_log' && message.data) {
                const logEntry = document.createElement('div');

                const senderId = message.data.sender_id || 'SYSTEM'; // Default if sender_id is null/undefined
                const agentStyle = getAgentColorStyle(senderId);

                logEntry.classList.add('log-entry', 'p-2', 'rounded', 'text-xs', 'mb-1', 'border', agentStyle.bg, agentStyle.border);

                const timestamp = new Date(message.data.timestamp || Date.now()).toLocaleTimeString();
                let contentHtml = '';
                // Ensure content is escaped
                const escapedContent = escapeHtml(typeof message.data.content === 'string' ? message.data.content : JSON.stringify(message.data.content, null, 2));

                if (typeof message.data.content === 'object') {
                    contentHtml = `<pre class="whitespace-pre-wrap text-xs ${agentStyle.text}">${escapedContent}</pre>`;
                } else {
                    // For plain string content, decide if specific text styling from agentStyle is desired or use a default.
                    // Using agentStyle.text for consistency here.
                    contentHtml = `<p class="whitespace-pre-wrap text-sm ${agentStyle.text}">${escapedContent}</p>`;
                }

                logEntry.innerHTML = `
                    <div class="font-semibold ${agentStyle.text}">
                        ${escapeHtml(timestamp)} |
                        <strong class="${agentStyle.text}">${escapeHtml(senderId)}</strong>
                        &rarr; ${escapeHtml(message.data.recipient_id || 'BROADCAST')}
                        (${escapeHtml(message.data.message_type)})
                    </div>
                    <div class="pl-2 mt-1">${contentHtml}</div>
                    <div class="text-gray-500 text-right text-xs mt-1">Session: ${escapeHtml(message.data.session_id)}</div>
                `;

                // If it was "Waiting for logs...", remove it
                const waitingMsg = logsContainer.querySelector('.text-gray-500');
                if (waitingMsg && waitingMsg.textContent === 'Waiting for logs...') {
                    logsContainer.innerHTML = '';
                }
                const connectedMsg = logsContainer.querySelector('.text-green-600');
                 if (connectedMsg && connectedMsg.textContent === 'Connected to real-time updates.') {
                    logsContainer.innerHTML = ''; // Clear "Connected..." message on first actual log
                }


                logsContainer.appendChild(logEntry);
                logsContainer.scrollTop = logsContainer.scrollHeight; // Auto-scroll
            } else if (message.type === 'debug_log' && message.data) {

                // REMOVED: const debugLogsContainer = document.getElementById('debug-logs-container');
                // REMOVED: const toggleDebugLogs = document.getElementById('toggle-debug-logs');

                // Use the 'toggleDebugLogs' and 'debugLogsContainer' from the outer scope (DOMContentLoaded)

                if (toggleDebugLogs && toggleDebugLogs.checked) {
                    const logEntry = document.createElement('div');
                    logEntry.classList.add('log-entry', 'p-1', 'rounded', 'text-xs', 'mb-1', 'font-mono'); // Added font-mono

                    const level = message.data.level ? message.data.level.toLowerCase() : 'info';
                    if (level === 'error') {
                        logEntry.classList.add('bg-red-50', 'text-red-700');
                    } else if (level === 'warning') {
                        logEntry.classList.add('bg-yellow-50', 'text-yellow-700');
                    } else if (level === 'debug') {
                        logEntry.classList.add('bg-blue-50', 'text-blue-700');
                    } else {
                        logEntry.classList.add('bg-gray-100');
                    }

                    const timestamp = new Date(message.data.timestamp * 1000).toLocaleTimeString();
                    const logMessage = message.data.message || '';
                    const module = message.data.module || 'unknown_module';
                    const funcName = message.data.funcName || 'unknown_function';
                    const lineno = message.data.lineno || '?';

                    logEntry.innerHTML = `
                        <div class="grid grid-cols-12 gap-x-1">
                            <span class="col-span-2 text-gray-600">${timestamp}</span>
                            <span class="col-span-1 font-semibold ${level === 'error' || level === 'warning' ? '' : 'text-gray-700'}">${message.data.level}</span>
                            <span class="col-span-3 text-purple-600">${module}.${funcName}:${lineno}</span>
                            <span class="col-span-6">${logMessage}</span>
                        </div>
                    `;

                    const waitingMsg = debugLogsContainer.querySelector('.text-gray-500');
                    if (waitingMsg && waitingMsg.textContent === 'Waiting for debug logs...') {
                        debugLogsContainer.innerHTML = '';
                    }
                    debugLogsContainer.appendChild(logEntry);
                    debugLogsContainer.scrollTop = debugLogsContainer.scrollHeight; // Auto-scroll
                }
            } else if ((message.type === 'ga_update' || message.type === 'ga_evaluation_complete' || message.type === 'ga_generation_complete' || message.type === 'ga_status_update') && message.data) {
                handleGaDataUpdate(message.data);
            } else if (message.type === 'agent_metric_update' && message.data) {
                const metricsData = message.data;
                if (metricsData.generation !== undefined && metricsData.best_fitness !== undefined) {
                    handleGaDataUpdate(metricsData);
                }
                const agentId = metricsData.agent_id;
                const metricsContainer = document.getElementById('agent-metrics-data');

                // Find or create a div for this agent's metrics
                let agentDiv = document.getElementById(`agent-metric-${agentId}`);
                if (!agentDiv) {
                    agentDiv = document.createElement('div');
                    agentDiv.id = `agent-metric-${agentId}`;
                    agentDiv.classList.add('agent-metric-entry', 'p-2', 'mb-2', 'border', 'rounded', 'bg-gray-50');

                    // If it's the first metric entry, clear the placeholder "Metrics will appear here."
                    const placeholder = metricsContainer.querySelector('p');
                    if (placeholder && placeholder.textContent === 'Metrics will appear here.') {
                        metricsContainer.innerHTML = '';
                    }
                    metricsContainer.appendChild(agentDiv);
                }

                // Update the content of the agent's div
                agentDiv.innerHTML = `
                    <h4 class="font-semibold text-md">${agentId}</h4>
                    <p class="text-sm">Messages Processed: <span class="font-medium">${metricsData.messages_processed}</span></p>
                    <p class="text-sm">Errors Encountered: <span class="font-medium text-red-600">${metricsData.errors_encountered}</span></p>
                    <p class="text-xs text-gray-500">Last updated: ${new Date(metricsData.timestamp).toLocaleTimeString()}</p>
                `;
            } else if (message.message) { // For generic messages like connection acks
                 const infoEntry = document.createElement('div');
                 infoEntry.classList.add('log-entry', 'p-1', 'text-sm', 'text-gray-600', 'italic');
                 infoEntry.textContent = `System: ${message.message}`;
                 logsContainer.appendChild(infoEntry);
                 logsContainer.scrollTop = logsContainer.scrollHeight;
            }
            // Add more handlers for other message types (agent_metrics, etc.)
        };

        socket.onerror = function(error) {
            console.error("WebSocket Error:", error);
            const errorEntry = document.createElement('div');
            errorEntry.classList.add('log-entry', 'text-red-600');
            errorEntry.textContent = 'WebSocket connection error. See console for details.';
            logsContainer.appendChild(errorEntry);
            logsContainer.scrollTop = logsContainer.scrollHeight;
        };

        socket.onclose = function(event) {
            console.log("WebSocket connection closed:", event);
            const closeEntry = document.createElement('div');
            closeEntry.classList.add('log-entry', 'text-orange-600');
            if (event.wasClean) {
                closeEntry.textContent = `WebSocket connection closed cleanly, code=${event.code} reason=${event.reason}`;
            } else {
                closeEntry.textContent = 'WebSocket connection died.';
            }
            logsContainer.appendChild(closeEntry);
            logsContainer.scrollTop = logsContainer.scrollHeight;
        };

        // Event Listeners for GA Control Buttons
        if (gaPauseBtn) {
            gaPauseBtn.addEventListener('click', async () => {
                try {
                    const response = await fetch('/api/ga/pause', { method: 'POST' });
                    const result = await response.json();
                    console.log('Pause response:', result);
                    // Optionally, show a small notification here e.g. using a toast library
                    // UI will update via WebSocket 'ga_update' message
                } catch (error) {
                    console.error('Error pausing GA:', error);
                    // Show error notification
                }
            });
        }

        if (gaResumeBtn) {
            gaResumeBtn.addEventListener('click', async () => {
                try {
                    const response = await fetch('/api/ga/resume', { method: 'POST' });
                    const result = await response.json();
                    console.log('Resume response:', result);
                } catch (error) {
                    console.error('Error resuming GA:', error);
                }
            });
        }

        if (gaCancelBtn) {
            gaCancelBtn.addEventListener('click', async () => {
                try {
                    const response = await fetch('/api/ga/cancel', { method: 'POST' });
                    const result = await response.json();
                    console.log('Cancel response:', result);
                } catch (error) {
                    console.error('Error cancelling GA:', error);
                }
            });
        }

        const toggleChart = document.getElementById('toggle-chart');
        const chartContainer = document.getElementById('ga-charts-placeholder');
        if (toggleChart && chartContainer) {
            toggleChart.addEventListener('change', () => {
                chartContainer.style.display = toggleChart.checked ? 'block' : 'none';
            });
        }

        const downloadCsvBtn = document.getElementById('download-csv');
        if (downloadCsvBtn) {
            downloadCsvBtn.addEventListener('click', () => {
                const rows = [['generation','best_fitness','average_fitness','min_fitness']];
                gaHistoryData.forEach(h => {
                    rows.push([h.generation, h.best_fitness, h.fitness_mean, h.fitness_min]);
                });
                const csvContent = rows.map(r => r.join(',')).join('\n');
                const blob = new Blob([csvContent], { type: 'text/csv' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = 'ga_metrics.csv';
                a.style.display = 'none';
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
            });
        }

        // Set initial state for buttons and fetch initial status
        // updateGaControlButtons('IDLE');
        // updateStatusBadge('IDLE');
        fetchInitialGaStatus();
        fetchGaHistory(); // Load history and initialize chart

    });
</script>
{% endblock %}
